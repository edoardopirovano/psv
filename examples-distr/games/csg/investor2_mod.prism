// EXAMPLE: INVESTING IN THE FUTURES MARKET
// (McIver and Morgan 03)

csg

player investor1 [no_invest1], [invest1], [cashin1] endplayer
player investor2 [no_invest2], [invest2], [cashin2] endplayer
player market1 [step] endplayer
player market2 [no_bar], [bar1], [bar2], [bar12] endplayer
player market3 [shares] endplayer
	
const int nrounds;

// module use to decide who can move
module month
	m : [0..1];
	r : [0.. nrounds];
	[step] (m=0) -> (m'=1); // start of month: invest and bar decision
	[step] (m=1) -> (m'=2); // shares change value
	[step] (m=2) & r<nrounds -> (m'=0) & (r'=r+1); // cash in shares if possible
endmodule

// investor 1
module investor1
	i1 : [0..1]; // i1=0 no reservation, i1=1 made reservation, i1=2 cashed in (done)
	[no_invest1] m=0 & (i1=0 | (i1=1 & b1=1)) -> (i1'=0); // do nothing
	[invest1] m=0 & (i1=0 | (i1=1 & b1=1)) -> (i1'=1); // make reservation
	[cashin1] m=2 & i1=1 & b1=0 -> (i1'=2); // cash in shares (not barred)
endmodule

// investor 1
module investor2
	i2 : [0..1]; // i2=0 no reservation, i2=1 made reservation, i2=2 cashed in
	[no_invest2] m=0 & (i2=0 | (i2=1 & b2=1)) -> (i2'=0); // do nothing
	[invest2] m=0 & (i2=0 | (i2=1 & b2=1)) -> (i2'=1); // make reservation
	[cashin2] m=2 & i2=1 & b2=0 -> (i2'=2); // cash in shares (not barred)
endmodule

// bar the investors
module bar
	b1 : [0..1] init 1; // initially cannot bar
	b2 : [0..1] init 1; // initially cannot bar
    	// b=0 - not barred and b=1 - barred
    	[no_bar] m=0 -> (b1'=0) & (b2'=0); // do not bar this month
    	[bar1] m=0 & b1=0 -> (b1'=1); // bar 1 this month (cannot have barred previous month) 
    	[bar2] m=0 & b2=0 -> (b2'=1); // bar 2 this month (cannot have barred previous month) 
    	[bar12] m=0 & b1=0 & b2=0 -> (b1'=1) & (b2'=1); // bar 1 and 2 this month (cannot have barred previous month) 
endmodule

// value of the shares
module value    
	v : [0..10] init 5;
	[shares] m=1 -> p/10 : (v'=min(v+1,c)) + (1-p/10) : (v'=min(max(v-1,0),c));
endmodule

// probability of shares going up/down
module probability
	p : [0..10] init 5; // probabilitity is p/10 and initially the probability is 1/2
	[shares] m=1 & v<5 -> 2/3 : (p'=min(p+1,10)) + 1/3 : (p'=max(p-1,0));
	[shares] m=1 & v=5 -> 1/2 : (p'=min(p+1,10)) + 1/2 : (p'=max(p-1,0));
	[shares] m=1 & v>5 -> 1/3 : (p'=min(p+1,10)) + 2/3 : (p'=max(p-1,0));
endmodule

// cap on the value of the shares
module cap
	c : [0..10] init 10; // cap on the shares
	[shares] m=1 -> 1/2 : (c'=max(c-1,0)) + 1/2 : (c'=c); // probability 1/2 the cap decreases
endmodule

// get reward when investor cashes in 
// (the investors gain less if the  cash in at the same time)
// add market rewards which are to minimise the investors?
rewards
	[cashin1] m=2 & i1=1 & b1=0 & !(i2=1 & b2=0) : v; // cash in alone
	[cashin1] m=2 & i1=1 & b1=0 & i2=1 & b2=0 : v*0.75; // both cash in
	[cashin2] m=2 & i2=1 & b2=0 & !(i1=1 & b1=0) : v; // cash in alone
	[cashin2] m=2 & i2=1 & b2=0 & i1=1 & b1=0 : v*0.75; // both cash in
endrewards

rewards "profit1_lc"
	// Use state rewards:
	//i=1 & b=0 & m=0 : v;
	// Could also use transition rewards
	[cashin1] m=2 & i1=1 & b1=0 & !(i2=1 & b2=0) : v * (1 + r/nrounds);
endrewards