csg

// constants
const double alpha;
const double pall = 0.5;
const double ponly = 0.5;
const double pnone = 0.5;
const double pfail =0.5;


// formulae
// agents send messages
formula p1 = mod(inm1+mod(ip1+c1,2),2);
formula p2 = mod(inm2+mod(ip2+c2,2),2);
formula p3 = mod(inm3+mod(ip3+c3,2),2);
// number of secrets sent
formula n = ps1+ps2+ps3; 
// number of secrets each agent has
formula n1 = 1+ps2+ps3;
formula n2 = 1+ps1+ps3;
formula n3 = 1+ps1+ps2;

player s
	[s0], [s1], [s2], [s3], [s4], [s5a], [s5b], [s5c], [s5d], [done]
endplayer

player p1
	[s11], [s21],
	[s31a], [s31b], //[s31c],
	[s41a], [s41b]
endplayer

player p2
	[s12], [s22], 
	[s32a], [s32b],// [s32c], 
	[s42a], [s42b]
endplayer

player p3
	[s13], [s23],
	[s33a], [s33b],// [s33c], 
	[s43a], [s43b]
endplayer

const rmax;

module steps
	s : [0..8] init 0; 
	r : [0..rmax] init 0;
	//step 1
	[s0] s=0 -> (s'=1); // random choices
	[s1] s=1 -> (s'=2); // sends/receive ci+ and ci-
	//step 2
	[s2] s=2 -> (s'=3); // send next values
	// step 3
	[s3] s=3 -> (s'=4); // send shared values or not
	// step 4
	[s4] s=4 -> (s'=5); // request new round or not
	[s5a] s=5 & r<rmax & s1 & s2 & s3 -> (s'=0); //restarts
	[s5b] s=5 & r<rmax & !(s1 & s2 & s3) & n=3 -> (s'=6); // stop and all have secret
	[s5c] s=5 & r<rmax & !(s1 & s2 & s3) & n<3 -> (s'=7); // stop and not all have secret
	[s5d] s=5 & r=rmax -> (s'=8); // run out of rounds
	
	[done] s>=6 -> true;
	
endmodule

module player1 //rational
	c1 : [0..1];
	c1p : [0..1];
	c1m : [0..1];
	inp1 : [0..1];
	inm1 : [0..1];
	ip1 : [0..1];
	s1 : bool;
	ps1 : [0..1] init 0;

	// internal computation (step 1a)
	[s0] s=0 -> alpha*1/2 : (c1'=1) & (c1p'=1) & (c1m'=mod(1+1,2))
			  + alpha*1/2 : (c1'=1) & (c1p'=0) & (c1m'=mod(1+0,2))
		  + (1-alpha)*1/2 : (c1'=0) & (c1p'=1) & (c1m'=mod(0+1,2))
		  + (1-alpha)*1/2 : (c1'=0) & (c1p'=0) & (c1m'=mod(0+0,2));

	// receives value from i^- and i^+ (step 1b)
	[s11] s=1 -> (inm1'=c3p) & (inp1'=c2m); 
	// receives value from i^+ (step 2)
	[s21] s=2 -> (ip1'=mod(inp2+c2,2)); 

	//decides to send or not
	[s31a] s=3 & p1=1 & c1=1 -> (ps1'=1);
	[s31b] s=3 & !(p1=1 & c1=1) -> (ps1'=0);
	//[s31c] s=3 & p1=1 & c1=1 -> (ps1'=0); // cheats

	// restart or stop
	[s41a] s=4 & ((p1=0 & n=0) | (p1=1 & n=1)) -> (s1'=true);
	[s41b] s=4 & !((p1=0 & n=0) | (p1=1 & n=1)) -> (s1'=false);
	
	//reset (when do not stop
	[s5a] s=5 -> (c1'=0) & (c1p'=0) & (c1m'=0) & (inp1'=0) & (inm1'=0) & (ip1'=0) &  (ps1'=0) & (s1'=false);
	
endmodule

module player2 //byzantine
	c2 : [0..1];
	c2p : [0..1];
	c2m : [0..1];
	inp2 : [0..1];
	inm2 : [0..1];
	ip2 : [0..1];
	s2 : bool;
	ps2 : [0..1] init 0;

	// internal computation (step 1a)
	[s0] s=0 -> alpha*1/2 : (c2'=1) & (c2p'=1) & (c2m'=mod(1+1,2))
			  + alpha*1/2 : (c2'=1) & (c2p'=0) & (c2m'=mod(1+0,2))
		  + (1-alpha)*1/2 : (c2'=0) & (c2p'=1) & (c2m'=mod(0+1,2))
		  + (1-alpha)*1/2 : (c2'=0) & (c2p'=0) & (c2m'=mod(0+0,2));

	// receives value from i^- and i^+ (step 1b)
	[s12] s=1 -> (inm2'=c1p) & (inp2'=c3m);
	// receives value from i^+ (step 2)
	[s22] s=2 -> (ip2'=mod(inp3+c3,2));

	//decides to send or not
	//[s32a] s=3 & p2=1 & c2=1 -> (ps2'=1);
	[s32a] s=3 & p2=1 & c2=1 -> pfail : (ps2'=0) + 1-pfail : (ps2'=1);
	//[s32b] s=3 & !(p2=1 & c2=1) -> (ps2'=0);
	[s32b] s=3 & !(p2=1 & c2=1) -> 1-pfail : (ps2'=0) + pfail : (ps2'=1);
	//[s32c] s=3 & p2=1 & c2=1 -> (ps2'=0); // cheats

	// restart or stop
	[s42a] s=4 & ((p2=0 & n=0) | (p2=1 & n=1)) -> (s2'=true);  
	[s42b] s=4 & !((p2=0 & n=0) | (p2=1 & n=1)) -> (s2'=false);

	//reset
	[s5a] s=5 -> (c2'=0) & (c2p'=0) & (c2m'=0) & (inp2'=0) & (inm2'=0) & (ip2'=0) & (ps2'=0) & (s2'=false);
	
endmodule

module player3 //altruistic
	c3: [0..1];
	c3p : [0..1];
	c3m : [0..1];
	inp3 : [0..1];
	inm3 : [0..1];
	ip3: [0..1];
	s3 : bool;
	ps3 : [0..1] init 0;

	// internal computation *** can send dual value?
	[s0] s=0 -> alpha*1/2 : (c3'=1) & (c3p'=1) & (c3m'=mod(1+1,2))
			  + alpha*1/2 : (c3'=1) & (c3p'=0) & (c3m'=mod(1+0,2))
		  + (1-alpha)*1/2 : (c3'=0) & (c3p'=1) & (c3m'=mod(0+1,2))
		  + (1-alpha)*1/2 : (c3'=0) & (c3p'=0) & (c3m'=mod(0+0,2));

	// receives value from i^- and i^+ (step 1b)
	[s13] s=1 -> (inm3'=c2p) & (inp3'=c1m);
	// receives value from i^+ (step 2)
	[s23] s=2 -> (ip3'=mod(inp1+c1,2));

	//decides to send or not
	[s33a] s=3 & p3=1 & c3=1 -> (ps3'=1);
	[s33b] s=3 & !(p3=1 & c3=1) -> (ps3'=0);
	//[s63c] (s=6) & (p3=1) & (c3=1) -> (ps3'=0); //cheats, don't sent when it should

	// restart or stop
	[s43a] s=4 & ((p3=0 & n=0) | (p3=1 & n=1)) -> (s3'=true);
	[s43b] s=4 & !((p3=0 & n=0) | (p3=1 & n=1)) -> (s3'=false);
	
	//reset
	[s5a] s=5 -> (c3'=0) & (c3p'=0) & (c3m'=0) & (inp3'=0) & (inm3'=0) & (ip3'=0) & (ps3'=0) & (s3'=false);
	
endmodule

rewards "steps"
	[s0] true : 1;
endrewards

