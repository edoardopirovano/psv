csg

const double alpha = 0.5;
const double pall = 0.5;
const double ponly = 0.5;
const double pnone = 0.5;
const double pfail = 0.25;

player s
	[s0], [s1], [s2], [s3], [s4], [s5], [s6], [s7], [s8], [s9], [s10], [s11], [s12]
endplayer

player p1
	[s31], [s41], [s51],
	[s61a], [s61b], //[s61c],
	[s71],
	[s81a], [s81b]
endplayer

player p2
	[s32], [s42], [s52], 
	[s62a], [s62b],// [s62c],
	[s72], 
	[s82a], [s82b]
endplayer

player p3
	[s33], [s43], [s53],
	[s63a], [s63b],// [s63c],
	[s73], 
	[s83a], [s83b]
endplayer

const rmax;

module steps
	s : [0..13] init 0; 
	r : [0..rmax] init 0;
	//step 1
	[s0] (s=0) -> (s'=1); //decides on ci
	[s1] (s=1) -> (s'=2); //decides on ci+
	[s2] (s=2) -> (s'=3); //computes ci-
	[s3] (s=3) -> (s'=4); //sends/receive ci+ and ci-
	//step 2
	[s4] (s=4) -> (s'=5); //sends ci+-
	[s5] (s=5) -> (s'=6); //computes p
	[s6] (s=6) -> (s'=7); 
	[s7] (s=7) -> (s'=8); //computes number ofshares
	[s8] (s=8) -> (s'=9);

	[s9] (s=9) & !(s1|s2|s3) -> (s'=10); // restarts as all want to restart
	[s9] (s=9) & (s1|s2|s3) & all -> (s'=11); //decides to stop and all have the secret
	[s9] (s=9) & (s1|s2|s3) & !all -> (s'=12);	// decide to stop and not all have the secret

	[s10] (s=10) & (r<rmax) -> (s'=0) & (r'=r+1); //restarts
	[s10] (s=10) & (r=rmax) -> (s'=13);

	//[s10] (s=10) -> (s'=0); //restarts	

	[s11] (s=11) -> (s'=13);
	[s12] (s=12) -> (s'=13);
endmodule

//problem with cheating detection?

//add intermediary states to account for transmission

module player1 //rational
	c1 : [0..1];
	c1p : [0..1];
	c1m : [0..1];
	inp1 : [0..1];
	inm1 : [0..1];
	ip1 : [0..1];
	p1 : [0..1];
	n1 : [0..3];
	s1 : bool;
	ps1 : [0..1] init 0;

	//internal computation can make a single step
	[s0] s=0 -> alpha : (c1'=1) + (1-alpha) : (c1'=0);
	[s1] s=1 -> 1/2 : (c1p'=1) + 1/2 : (c1p'=0);
	[s2] s=2 -> (c1m'=mod(c1+c1p,2));

	//receives values
	[s31] (s=3) -> (inm1'=c3p) & (inp1'=c2m); 
	[s41] (s=4) -> (ip1'=mod(inp2+c2,2)); 

	//internal computation 
	[s51] (s=5) -> (p1'=mod(inm1+mod(ip1+c1,2),2));

	//decides to send or not
	[s61a] (s=6) & (p1=1) & (c1=1) -> (ps1'=1);
	[s61b] (s=6) & !((p1=1) & (c1=1)) -> (ps1'=0);
	//[s61c] (s=6) & (p1=1) & (c1=1) -> (ps1'=0); // cheats

	//computes number of shares
	[s71] (s=7) -> (n1'=ps1+ps2+ps3); 

	//decides whether or not to stop
	[s81a] (s=8) & (((p1=0) & (n1=0)) | ((p1=1) & (n1=1))) -> (s1'=false);
	[s81b] (s=8) & !(((p1=0) & (n1=0)) | ((p1=1) & (n1=1))) -> (s1'=true);

	//reset
	[s10] (s=10) -> (c1'=0) & (c1p'=0) & (c1m'=0) & (inp1'=0) & (inm1'=0) & (ip1'=0) & (p1'=0) & (n1'=0) & (ps1'=0) & (s1'=false);
endmodule

module player2 //byzantine
	c2 : [0..1];
	c2p : [0..1];
	c2m : [0..1];
	inp2 : [0..1];
	inm2 : [0..1];
	ip2 : [0..1];
	p2 : [0..1];
	n2 : [0..3];
	s2 : bool;
	ps2 : [0..1] init 0;

	//internal computation
	[s0] true -> alpha : (c2'=1) + (1-alpha) : (c2'=0);
	[s1] true -> 1/2 : (c2p'=1) + 1/2 : (c2p'=0);
	[s2] true -> (c2m'=mod(c2+c2p,2));

	//receives values
	[s32] (s=3) -> (inm2'=c1p) & (inp2'=c3m);
	[s42] (s=4) -> (ip2'=mod(inp3+c3,2));

	//internal computation	
	[s52] (s=5) -> (p2'=mod(inm2+mod(ip2+c2,2),2));

	//decides to send or not
	[s62a] (s=6) & (p2=1) & (c2=1) -> (ps2'=1);
	//[s62a] (s=6) & (p2=1) & (c2=1) -> pfail : (ps2'=0) + 1-pfail : (ps2'=1);
	[s62b] (s=6) & !((p2=1) & (c2=1)) -> (ps2'=0);
	//[s62b] (s=6) & !((p2=1) & (c2=1)) -> 1-pfail : (ps2'=0) + pfail : (ps2'=1);
	//[s62c] (s=6) & (p2=1) & (c2=1) -> (ps2'=0); //cheats, don't sent when it should

	//computes number of shares
	[s72] (s=7) -> (n2'=ps1+ps2+ps3); //normal case

	//decides whether or not to stop
	[s82a] (s=8) & (((p2=0) & (n2=0)) | ((p2=1) & (n2=1))) -> (s2'=false);  
	[s82b] (s=8) & !(((p2=0) & (n2=0)) | ((p2=1) & (n2=1))) -> (s2'=true);

	//reset
	[s10] (s=10) -> (c2'=0) & (c2p'=0) & (c2m'=0) & (inp2'=0) & (inm2'=0) & (ip2'=0) & (p2'=0) & (n2'=0) & (ps2'=0) & (s2'=false);
endmodule

module player3 //altruistic
	c3: [0..1];
	c3p : [0..1];
	c3m : [0..1];
	inp3 : [0..1];
	inm3 : [0..1];
	ip3: [0..1];
	p3 : [0..1];
	n3 : [0..3];
	s3 : bool;
	ps3 : [0..1] init 0;

	//internal computation
	[s0] true -> alpha : (c3'=1) + (1-alpha) : (c3'=0);
	[s1] true -> 1/2 : (c3p'=1) + 1/2 : (c3p'=0);
	[s2] true -> (c3m'=mod(c3+c3p,2));

	//receives values
	[s33] (s=3) -> (inm3'=c2p) & (inp3'=c1m);
	[s43] (s=4) -> (ip3'=mod(inp1+c1,2));

	//internal computation	
	[s53] (s=5) -> (p3'=mod(inm3+mod(ip3+c3,2),2));

	//decides to send or not
	[s63a] (s=6) & (p3=1) & (c3=1) -> (ps3'=1);
	[s63b] (s=6) & !((p3=1) & (c3=1)) -> (ps3'=0);
	//[s63c] (s=6) & (p3=1) & (c3=1) -> (ps3'=0); //cheats, don't sent when it should

	//computes number of shares
	[s73] (s=7) -> (n3'=ps1+ps2+ps3); //normal case
	
	//decides whether or not to stop
	[s83a] (s=8) & (((p3=0) & (n3=0)) | ((p3=1) & (n3=1))) -> (s3'=false);
	[s83b] (s=8) & !(((p3=0) & (n3=0)) | ((p3=1) & (n3=1))) -> (s3'=true);
	
	//reset
	[s10] (s=10) -> (c3'=0) & (c3p'=0) & (c3m'=0) & (inp3'=0) & (inm3'=0) & (ip3'=0) & (p3'=0) & (n3'=0) & (ps3'=0) & (s3'=false);
endmodule

formula p1c1 = ((p1 = 1) & (c1 = 1))? 1 : 0;
formula p2c2 = ((p2 = 1) & (c2 = 1))? 1 : 0;
formula p3c3 = ((p3 = 1) & (c3 = 1))? 1 : 0;
formula miss = ((mod(c2+c2p,2)) = 1)? 0 : 1;
formula invc2m = (c2m = 0)? 1 : 0;
formula allshared = (p1=1 & p2=1 & p3=1);

formula only1 = (n1=3 & n2<3 & n3<3);
formula and1 = (n1=3 & ((n2=3 & n3<3) | (n2!=3 & n3=3)));
formula ab1 = (n1<3 & n2=3 & n3=3);
formula obn1 = (n1<3 & ((n2<3 & n3=3) | (n2=3 & n3<3)));

formula only2 = (n2=3 & n1<3 & n3<3);
formula and2 = (n1=3 & ((n2=3 & n3<3) | (n2!=3 & n3=3)));
formula ab2 = (n2<3 & n1=3 & n3=3);
formula obn2 = (n2<3 & ((n1<3 & n3=3) | (n1=3 & n3<3)));

formula only3 = (n3=3 & n1<3 & n2<3);
formula and3 = (n3=3 & ((n1=3 & n2<3) | (n1<3 & n2=3)));
formula ab3 = (n3<3 & n1=3 & n2=3);
formula on3 = (n3<3 & ((n1<3 & n2=3) | (n1=3 & n2<3)));

formula all = (n1=3 & n2=3 & n3=3);
formula none = (n2<3 & n1<3 & n3<3);

formula xort = (((c1=1&c2=0&c3=0) | (c1=0&c2=1&c3=0) | (c1=0&c2=0&c3=1))? 1 : 0);

rewards "steps"
	[s9] true : 1;
endrewards

rewards "r01"
	((s=12) | ((s=10) & r=rmax)) & (n1<3 & n2=3 & n3=3) : -2; //only 2 and 3
	((s=12) | ((s=10) & r=rmax)) & (n2<3 & n1=3 & n3=3) : 1; //only 1 and 3 
	((s=12) | ((s=10) & r=rmax)) & (n3<3 & n1=3 & n2=3) : 1; //only 1 and 2

	((s=12) | ((s=10) & r=rmax)) & (n1<3 & n2<3 & n3<3) : pnone; //nobody
	((s=11) | ((s=10) & r=rmax)) & (n1=3 & n2=3 & n3=3) : pall; //everybody

	((s=12) | ((s=10) & r=rmax)) & (n1=3 & n2<3 & n3<3) : ponly; //only 1
	((s=12) | ((s=10) & r=rmax)) & (n2=3 & n1<3 & n3<3) : -1; //only 2
	((s=12) | ((s=10) & r=rmax)) & (n3=3 & n1<3 & n2<3) : -1; //only 3
endrewards

rewards "r02"
	(s=9) & (n1<3 & n2=3 & n3=3) : 2; //only 2 and 3
	(s=9) & (n2<3 & n1=3 & n3=3) : -2; //only 1 and 3 
	(s=9) & (n3<3 & n1=3 & n2=3) : 2; //only 1 and 2

	(s=9) & (n1<3 & n2<3 & n3<3) : pnone; //nobody
	(s=9) & (n1=3 & n2=3 & n3=3) : pall; //everybody

	(s=9) & (n1=3 & n2<3 & n3<3) : -1; //only 1
	(s=9) & (n2=3 & n1<3 & n3<3) : ponly; //only 2
	(s=9) & (n3=3 & n1<3 & n2<3) : -1; //only 3
endrewards

rewards "r03"
	(s=9) & (n1<3 & n2=3 & n3=3) : 2; //only 2 and 3
	(s=9) & (n2<3 & n1=3 & n3=3) : 2; //only 1 and 3 
	(s=9) & (n3<3 & n1=3 & n2=3) : -2; //only 1 and 2

	(s=9) & (n1<3 & n2<3 & n3<3) : pnone; //nobody
	(s=9) & (n1=3 & n2=3 & n3=3) : pall; //everybody

	(s=9) & (n1=3 & n2<3 & n3<3) : -1; //only 1
	(s=9) & (n2=3 & n1<3 & n3<3) : -1; //only 2
	(s=9) & (n3=3 & n1<3 & n2<3) : ponly; //only 3
endrewards

rewards "r12"
	(s=9) & (n1<3 & n2=3 & n3=3) : 0; //only 2 and 3
	(s=9) & (n2<3 & n1=3 & n3=3) : 0; //only 1 and 3 
	(s=9) & (n3<3 & n1=3 & n2=3) : 4; //only 1 and 2

	(s=9) & (n1<3 & n2<3 & n3<3) : 2*pnone; //nobody
	(s=9) & (n1=3 & n2=3 & n3=3) : 2*pall; //everybody

	(s=9) & (n1=3 & n2<3 & n3<3) : ponly -1; //only 1
	(s=9) & (n2=3 & n1<3 & n3<3) : ponly -1; //only 2
	(s=9) & (n3=3 & n1<3 & n2<3) : -2; //only 3
endrewards

rewards "r123"
	(s=9) & (n1<3 & n2=3 & n3=3) : 2; //only 2 and 3
	(s=9) & (n2<3 & n1=3 & n3=3) : 2; //only 1 and 3 
	(s=9) & (n3<3 & n1=3 & n2=3) : 2; //only 1 and 2

	(s=9) & (n1<3 & n2<3 & n3<3) : 3*pnone; //nobody
	(s=9) & (n1=3 & n2=3 & n3=3) : 3*pall; //everybody

	(s=9) & (n1=3 & n2<3 & n3<3) : ponly-2; //only 1
	(s=9) & (n2=3 & n1<3 & n3<3) : ponly-2; //only 2
	(s=9) & (n3=3 & n1<3 & n2<3) : ponly-2; //only 3
endrewards

rewards "rs"
	(s=9) & (n1<3 & n2=3 & n3=3) : -2; //only 2 and 3
	(s=9) & (n2<3 & n1=3 & n3=3) : -2; //only 1 and 3 
	(s=9) & (n3<3 & n1=3 & n2=3) : -2; //only 1 and 2

	(s=9) & (n1<3 & n2<3 & n3<3) : -3*pnone; //nobody
	(s=9) & (n1=3 & n2=3 & n3=3) : -3*pall; //everybody

	(s=9) & (n1=3 & n2<3 & n3<3) : 2-ponly; //only 1
	(s=9) & (n2=3 & n1<3 & n3<3) : 2-ponly; //only 2
	(s=9) & (n3=3 & n1<3 & n2<3) : 2-ponly; //only 3
endrewards

rewards "r1"
	(s=9) & (n1=3 & n2<3 & n3<3) : 3;
	(s=9) & (n1=3 & ((n2=3 & n3<3) | (n2<3 & n3=3))) : 2;
	(s=9) & (n1=3 & n2=3 & n3=3) : 1;
	(s=9) & (n1<3 & n2<3 & n3<3) : 0;
	(s=9) & (n1<3 & ((n2<3 & n3=3) | (n2=3 & n3<3))) : -1;
	(s=9) & (n1<3 & n2=3 & n3=3) : -2;
endrewards

rewards "r2"
	(s=9) & (n2=3 & n1<3 & n3<3) : 3;
	(s=9) & (n2=3 & ((n1=3 & n3<3) | (n1<3 & n3=3) )) : 2;
	(s=9) & (n2=3 & n1=3 & n3=3) : 1;
	(s=9) & (n2<3 & n1<3 & n3<3) : 0;
	(s=9) & (n2<3 & ((n1<3 & n3=3) | (n1=3 & n3<3))) : -1;
	(s=9) & (n2<3 & n1=3 & n3=3) : -2;
endrewards

rewards "r3"
	(s=9) & (n3=3 & n1<3 & n2<3) : 3;
	(s=9) & (n3=3 & ((n1=3 & n2<3) | (n1<3 & n2=3) )) : 2;
	(s=9) & (n3=3 & n1=3 & n2=3) : 1;
	(s=9) & (n3<3 & n1<3 & n2<3) : 0;
	(s=9) & (n3<3 & ((n1<3 & n2=3) | (n1=3 & n2>3))) : -1;
	(s=9) & (n3<3 & n1=3 & n2=3) : -2;
endrewards