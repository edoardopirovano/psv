csg

//label "adv" = true;

// constants
const double alpha;
const double pall = 0.5;
const double ponly = 0.5;
const double pnone = 0.5;
const double pfail;


// formulae
// agents send messages

formula inm1=c3p;
formula inm2=c1p;
formula inm3=c2p;

formula inp1=c2m;
formula inp2=c3m;
formula inp3=c1m;

formula ip1=mod(inp2+c2,2);
formula ip2=mod(inp3+c3,2);
formula ip3=mod(inp1+c1,2);

formula p1 = mod(inm1+mod(ip1+c1,2),2);
formula p2 = mod(inm2+mod(ip2+c2,2),2);
formula p3 = mod(inm3+mod(ip3+c3,2),2);

// number of secrets sent
formula n = ps1+ps2+ps3; 
// number of secrets each agent has
formula n1 = 1+ps2+ps3;
formula n2 = 1+ps1+ps3;
formula n3 = 1+ps1+ps2;

player s
	[c], [s0], [s3], [s4], [s5a], [s5b], [s5c], [s5d], [done]
endplayer

player p1
	[c10], [c11],
	[s31a], [s31b], [s31c],
	[s41a], [s41b]
endplayer

player p2
	[c2],
	[s32a], [s32b],// [s32c], 
	[s42a], [s42b]
endplayer

player p3
	[c30], [c31],
	[s33a], [s33b], [s33c], 
	[s43a], [s43b]
endplayer

const rmax;

module steps
	s : [0..8] init 0; 
	r : [0..rmax] init 0;

	[c] s=0 -> (s'=1);

	//step 1
	[s0] s=1 -> (s'=3); // random choices

	[s3] s=3 -> (s'=4); // send shared values or not
	// step 4
	[s4] s=4 -> (s'=5); // request new round or not
	[s5a] s=5 & r<rmax & s1 & s2 & s3 -> (s'=0); //restarts
	[s5b] s=5 & r<rmax & !(s1 & s2 & s3) & n=3 -> (s'=6); // stop and all have secret
	[s5c] s=5 & r<rmax & !(s1 & s2 & s3) & n<3 -> (s'=7); // stop and not all have secret
	[s5d] s=5 & r=rmax -> (s'=8); // run out of rounds
	
	[done] s>=6 -> true;
	
endmodule

module player1 //rational
	c1 : [0..1];
	c1p : [0..1];
	c1m : [0..1];
	s1 : bool;
	ps1 : [0..1] init 0;
	cheat1 : [0..1];
	
	[c10] s=0 -> (cheat1'=0);
	[c11] s=0 -> (cheat1'=1);

	// internal computation (step 1a)
	[s0] s=1 -> alpha*1/2 : (c1'=1) & (c1p'=1) & (c1m'=mod(1+1,2))
			  + alpha*1/2 : (c1'=1) & (c1p'=0) & (c1m'=mod(1+0,2))
		  + (1-alpha)*1/2 : (c1'=0) & (c1p'=1) & (c1m'=mod(0+1,2))
		  + (1-alpha)*1/2 : (c1'=0) & (c1p'=0) & (c1m'=mod(0+0,2));

	//decides to send or not
	[s31a] s=3 & p1=1 & c1=1 & cheat1=0 -> (ps1'=1);
	[s31b] s=3 & !(p1=1 & c1=1) -> (ps1'=0);
	[s31c] s=3 & p1=1 & c1=1 & cheat1=1 -> (ps1'=0); // cheats

	// restart or stop
	[s41a] s=4 & ((p1=0 & n=0) | (p1=1 & n=1)) -> (s1'=true);
	[s41b] s=4 & !((p1=0 & n=0) | (p1=1 & n=1)) -> (s1'=false);
	
	//reset (when do not stop
	[s5a] s=5 -> (c1'=0) & (c1p'=0) & (c1m'=0) & (ps1'=0) & (s1'=false) & (cheat1'=0);
	
endmodule

module player2 //byzantine
	c2 : [0..1];
	c2p : [0..1];
	c2m : [0..1];
	s2 : bool;
	ps2 : [0..1] init 0;
	
	[c2] s=0 -> true;
	
	// internal computation (step 1a)
	[s0] s=1 -> alpha*1/2 : (c2'=1) & (c2p'=1) & (c2m'=mod(1+1,2))
			  + alpha*1/2 : (c2'=1) & (c2p'=0) & (c2m'=mod(1+0,2))
		  + (1-alpha)*1/2 : (c2'=0) & (c2p'=1) & (c2m'=mod(0+1,2))
		  + (1-alpha)*1/2 : (c2'=0) & (c2p'=0) & (c2m'=mod(0+0,2));

	//decides to send or not
	//[s32a] s=3 & p2=1 & c2=1 -> (ps2'=1);
	[s32a] s=3 & p2=1 & c2=1 -> pfail : (ps2'=0) + 1-pfail : (ps2'=1);
	//[s32b] s=3 & !(p2=1 & c2=1) -> (ps2'=0);
	[s32b] s=3 & !(p2=1 & c2=1) -> 1-pfail : (ps2'=0) + pfail : (ps2'=1);
	//[s32c] s=3 & p2=1 & c2=1 -> (ps2'=0); // cheats

	// restart or stop
	[s42a] s=4 & ((p2=0 & n=0) | (p2=1 & n=1)) -> (s2'=true);  
	[s42b] s=4 & !((p2=0 & n=0) | (p2=1 & n=1)) -> (s2'=false);

	//reset
	[s5a] s=5 -> (c2'=0) & (c2p'=0) & (c2m'=0) & (ps2'=0) & (s2'=false);
	
endmodule

module player3 //rational
	c3: [0..1];
	c3p : [0..1];
	c3m : [0..1];
	s3 : bool;
	ps3 : [0..1] init 0;
	cheat3 : [0..1];
	
	[c30] s=0 -> (cheat3'=0);
	[c31] s=0 -> (cheat3'=1);

	// internal computation *** can send dual value?
	[s0] s=1 -> alpha*1/2 : (c3'=1) & (c3p'=1) & (c3m'=mod(1+1,2))
			  + alpha*1/2 : (c3'=1) & (c3p'=0) & (c3m'=mod(1+0,2))
		  + (1-alpha)*1/2 : (c3'=0) & (c3p'=1) & (c3m'=mod(0+1,2))
		  + (1-alpha)*1/2 : (c3'=0) & (c3p'=0) & (c3m'=mod(0+0,2));

	//decides to send or not
	[s33a] s=3 & p3=1 & c3=1 & cheat3=0 -> (ps3'=1);
	[s33b] s=3 & !(p3=1 & c3=1) -> (ps3'=0);
	[s33c] s=3 & p3=1 & c3=1 & cheat3=1 -> (ps3'=0); //cheats, don't sent when it should

	// restart or stop
	[s43a] s=4 & ((p3=0 & n=0) | (p3=1 & n=1)) -> (s3'=true);
	[s43b] s=4 & !((p3=0 & n=0) | (p3=1 & n=1)) -> (s3'=false);
	
	//reset
	[s5a] s=5 -> (c3'=0) & (c3p'=0) & (c3m'=0) & (ps3'=0) & (s3'=false) & (cheat3'=0);
	
endmodule

rewards "steps"
	[s0] true : 1;
endrewards

rewards "player1"
	
	[s5b] n1=3 & n2<3 & n3<3 : 3;
	[s5b] n1=3 & ((n2=3 & n3<3) | (n2<3 & n3=3)) : 2;
	[s5b] n1=3 & n2=3 & n3=3 : 1;
	[s5b] n1<3 & n2<3 & n3<3 : 0;
	[s5b] n1<3 & n2=3 & n3=3 : -1;
	[s5b] n1<3 & ((n2=3 & n3<3) | (n2<3 & n3=3)) : -2;

	[s5c] n1=3 & n2<3 & n3<3 : 3;
	[s5c] n1=3 & ((n2=3 & n3<3) | (n2<3 & n3=3)) : 2;
	[s5c] n1=3 & n2=3 & n3=3 : 1;
	[s5c] n1<3 & n2<3 & n3<3 : 0;
	[s5c] n1<3 & n2=3 & n3=3 : -1;
	[s5c] n1<3 & ((n2=3 & n3<3) | (n2<3 & n3=3)) : -2;

endrewards